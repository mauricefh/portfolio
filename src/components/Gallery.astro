---
// Gallery.astro
const { medias } = Astro.props;
---

<div
  class="gallery-root group"
  data-medias={JSON.stringify(medias)}
  tabindex="-1"
>
  <div class="overlays"></div>

  <div class="media-container">
    <img
      class="gallery-image"
      src=""
      alt="Gallery Image"
      style="display: none;"
    />
    <video class="gallery-video" controls playsinline style="display: none;"
    ></video>
  </div>

  <svg
    class="control btn-fullscreen"
    viewBox="0 0 64 64"
    fill="none"
    stroke="black"
  >
    <polyline points="20 8 8 8 8 20"></polyline><line
      x1="8"
      y1="8"
      x2="24"
      y2="24"></line>
    <polyline points="56 20 56 8 44 8"></polyline><line
      x1="56"
      y1="8"
      x2="40"
      y2="24"></line>
    <polyline points="44 56 56 56 56 44"></polyline><line
      x1="56"
      y1="56"
      x2="40"
      y2="40"></line>
    <polyline points="8 44 8 56 20 56"></polyline><line
      x1="8"
      y1="56"
      x2="24"
      y2="40"></line>
  </svg>

  <svg class="control btn-close" viewBox="0 0 24 24" fill="none" stroke="black">
    <path
      d="M7 17L16.8995 7.10051"
      stroke-linecap="round"
      stroke-linejoin="round"></path>
    <path
      d="M7 7.00001L16.8995 16.8995"
      stroke-linecap="round"
      stroke-linejoin="round"></path>
  </svg>

  <div class="control chevron nav-left">&#x276E</div>
  <div class="control chevron nav-right">&#x276F</div>

  <div class="media-counter">
    <span class="current-index">1</span> / <span class="total-count">0</span>
  </div>
</div>

<style>
  .gallery-root {
    position: relative;
    background-color: black;
    width: 100%;
    height: 100%;
    touch-action: pan-y;
    overflow: hidden;
    /* FIX: Create a local stacking context so buttons 
       don't leak out to other cards */
    isolation: isolate;
    z-index: 1;
  }

  .gallery-root:focus {
    outline: none;
  }

  .overlays {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: hsla(0, 0%, 0%, 85%);
    z-index: -1; /* Sit behind the fullscreen media but inside the root */
  }

  .media-container {
    width: 100%;
    height: 100%;
    transition: opacity 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .gallery-image,
  .gallery-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Fullscreen Mode Scoping - Using :fullscreen pseudo-class */
  .gallery-root:fullscreen,
  .gallery-root:-webkit-full-screen,
  .gallery-root:-moz-full-screen,
  .gallery-root:-ms-fullscreen {
    background-color: black;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  /* Fallback for browsers without Fullscreen API support */
  .gallery-root.fullscreen-mode {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 99999 !important;
    background-color: black;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .gallery-root:fullscreen .overlays,
  .gallery-root:-webkit-full-screen .overlays,
  .gallery-root:-moz-full-screen .overlays,
  .gallery-root:-ms-fullscreen .overlays,
  .fullscreen-mode .overlays {
    display: block;
  }

  .gallery-root:fullscreen .media-container,
  .gallery-root:-webkit-full-screen .media-container,
  .gallery-root:-moz-full-screen .media-container,
  .gallery-root:-ms-fullscreen .media-container,
  .fullscreen-mode .media-container {
    width: 80vw;
    height: 80vh;
  }

  /* Controls Management */
  .control {
    cursor: pointer;
    z-index: 7000;
    position: absolute;
  }

  .btn-fullscreen,
  .btn-close {
    top: 12px;
    right: 12px;
    width: 40px;
    height: 40px;
    background-color: hsla(0deg, 0%, 100%, 75%);
    border-radius: 50%;
    padding: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .btn-close {
    display: none;
  }

  .gallery-root:fullscreen .btn-fullscreen,
  .gallery-root:-webkit-full-screen .btn-fullscreen,
  .gallery-root:-moz-full-screen .btn-fullscreen,
  .gallery-root:-ms-fullscreen .btn-fullscreen,
  .fullscreen-mode .btn-fullscreen {
    display: none;
  }

  .gallery-root:fullscreen .btn-close,
  .gallery-root:-webkit-full-screen .btn-close,
  .gallery-root:-moz-full-screen .btn-close,
  .gallery-root:-ms-fullscreen .btn-close,
  .fullscreen-mode .btn-close {
    display: flex;
  }

  .chevron {
    top: 50%;
    transform: translateY(-50%);
    background-color: hsla(0deg, 0%, 100%, 70%);
    border: 1px solid black;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .nav-left {
    left: 16px;
  }
  .nav-right {
    right: 16px;
  }

  .media-counter {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translate(-50%);
    background-color: hsla(0deg, 0%, 0%, 60%);
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-family: sans-serif;
    font-size: 14px;
    z-index: 7000;
  }

  @media (max-width: 768px) {
    .chevron {
      display: none;
    }
  }
</style>

<script>
  // Fullscreen API with vendor prefix support
  const fullscreenAPI = {
    // Check if Fullscreen API is supported
    isSupported: () => {
      return !!(
        document.fullscreenEnabled ||
        document.webkitFullscreenEnabled ||
        document.mozFullScreenEnabled ||
        document.msFullscreenEnabled
      );
    },

    // Request fullscreen on an element
    request: (element) => {
      if (element.requestFullscreen) {
        return element.requestFullscreen();
      } else if (element.webkitRequestFullscreen) {
        return element.webkitRequestFullscreen();
      } else if (element.mozRequestFullScreen) {
        return element.mozRequestFullScreen();
      } else if (element.msRequestFullscreen) {
        return element.msRequestFullscreen();
      }
      return Promise.reject(new Error("Fullscreen not supported"));
    },

    // Exit fullscreen
    exit: () => {
      if (document.exitFullscreen) {
        return document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        return document.webkitExitFullscreen();
      } else if (document.mozCancelFullScreen) {
        return document.mozCancelFullScreen();
      } else if (document.msExitFullscreen) {
        return document.msExitFullscreen();
      }
      return Promise.reject(new Error("Fullscreen not supported"));
    },

    // Get currently fullscreen element
    getElement: () => {
      return (
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement
      );
    },

    // Get the event name for fullscreen changes
    getChangeEventName: () => {
      if (document.fullscreenEnabled) return "fullscreenchange";
      if (document.webkitFullscreenEnabled) return "webkitfullscreenchange";
      if (document.mozFullScreenEnabled) return "mozfullscreenchange";
      if (document.msFullscreenEnabled) return "MSFullscreenChange";
      return null;
    },

    // Get the event name for fullscreen errors
    getErrorEventName: () => {
      if (document.fullscreenEnabled) return "fullscreenerror";
      if (document.webkitFullscreenEnabled) return "webkitfullscreenerror";
      if (document.mozFullScreenEnabled) return "mozfullscreenerror";
      if (document.msFullscreenEnabled) return "MSFullscreenError";
      return null;
    },
  };

  function initGalleries() {
    const galleries = document.querySelectorAll(".gallery-root");

    galleries.forEach((gallery) => {
      if (gallery.getAttribute("data-initialized")) return;
      gallery.setAttribute("data-initialized", "true");

      const mediaItems = JSON.parse(gallery.dataset.medias);
      const container = gallery.querySelector(".media-container");
      const img = gallery.querySelector(".gallery-image");
      const vid = gallery.querySelector(".gallery-video");
      const currentLabel = gallery.querySelector(".current-index");
      const totalLabel = gallery.querySelector(".total-count");

      let index = 0;
      totalLabel.textContent = mediaItems.length;

      const update = (skip = false) => {
        const item = mediaItems[index];
        const swap = () => {
          vid.pause();
          vid.src = "";
          if (item.type === "video") {
            img.style.display = "none";
            vid.style.display = "block";
            vid.src = item.url;
            vid.play().catch(() => {});
          } else {
            vid.style.display = "none";
            img.style.display = "block";
            img.src = item.url;
          }
          currentLabel.textContent = index + 1;
        };
        if (skip) return swap();
        container.style.opacity = "0";
        setTimeout(() => {
          swap();
          container.style.opacity = "1";
        }, 200);
      };

      update(true);

      // Navigation
      gallery.querySelector(".nav-left").onclick = (e) => {
        e.stopPropagation();
        index = (index - 1 + mediaItems.length) % mediaItems.length;
        update();
      };
      gallery.querySelector(".nav-right").onclick = (e) => {
        e.stopPropagation();
        index = (index + 1) % mediaItems.length;
        update();
      };

      // Fullscreen Management
      const enterFullscreen = async () => {
        // Check if Fullscreen API is supported
        if (!fullscreenAPI.isSupported()) {
          console.warn(
            "Fullscreen API not supported, falling back to CSS fullscreen",
          );
          // Fallback to CSS fullscreen for unsupported browsers
          gallery.classList.add("fullscreen-mode");
          document.body.style.overflow = "hidden";
          // Set object-fit directly via JS
          img.style.objectFit = "contain";
          vid.style.objectFit = "contain";
          return;
        }

        try {
          // Set object-fit to contain before entering fullscreen
          img.style.objectFit = "contain";
          vid.style.objectFit = "contain";

          // Request fullscreen on the gallery element itself
          await fullscreenAPI.request(gallery);
          // The fullscreenchange event will handle UI updates
        } catch (err) {
          console.error("Failed to enter fullscreen:", err);
          // Fallback to CSS fullscreen if request fails
          gallery.classList.add("fullscreen-mode");
          document.body.style.overflow = "hidden";
          img.style.objectFit = "contain";
          vid.style.objectFit = "contain";
        }
      };

      const exitFullscreen = async () => {
        // Check if we're currently in fullscreen
        const fullscreenElement = fullscreenAPI.getElement();

        if (fullscreenElement === gallery) {
          // We're in native fullscreen, exit it
          try {
            // Reset object-fit to cover before exiting
            img.style.objectFit = "cover";
            vid.style.objectFit = "cover";

            await fullscreenAPI.exit();
            // The fullscreenchange event will handle UI updates
          } catch (err) {
            console.error("Failed to exit fullscreen:", err);
          }
        } else if (gallery.classList.contains("fullscreen-mode")) {
          // We're in CSS fallback fullscreen
          gallery.classList.remove("fullscreen-mode");
          document.body.style.overflow = "";
          // Reset object-fit to cover
          img.style.objectFit = "cover";
          vid.style.objectFit = "cover";
        }
      };

      // Handle fullscreen state changes (including Escape key)
      const handleFullscreenChange = () => {
        const fullscreenElement = fullscreenAPI.getElement();
        const isFullscreen = fullscreenElement === gallery;

        // Update UI to reflect fullscreen state
        if (!isFullscreen) {
          // Clean up when exiting fullscreen
          gallery.classList.remove("fullscreen-mode");
          document.body.style.overflow = "";

          // Reset object-fit to cover when exiting fullscreen
          img.style.objectFit = "cover";
          vid.style.objectFit = "cover";

          // Restore other galleries
          const allGalleries = document.querySelectorAll(".gallery-root");
          allGalleries.forEach((g) => {
            g.style.zIndex = "1";
            g.style.pointerEvents = "auto";
          });
        } else {
          // Optional: Add class for additional styling if needed
          gallery.classList.add("fullscreen-mode");

          // Set object-fit to contain when entering fullscreen
          img.style.objectFit = "contain";
          vid.style.objectFit = "contain";

          // Hide other galleries while this one is fullscreen
          const allGalleries = document.querySelectorAll(".gallery-root");
          allGalleries.forEach((g) => {
            if (g !== gallery) {
              g.style.zIndex = "0";
              g.style.pointerEvents = "none";
            }
          });
        }
      };

      // Handle fullscreen errors
      const handleFullscreenError = (e) => {
        console.error("Fullscreen error:", e);
        // Fallback to CSS fullscreen
        gallery.classList.add("fullscreen-mode");
        document.body.style.overflow = "hidden";
      };

      // Fullscreen button
      gallery.querySelector(".btn-fullscreen").onclick = (e) => {
        e.stopPropagation();
        enterFullscreen();
      };

      // Close button
      gallery.querySelector(".btn-close").onclick = (e) => {
        e.stopPropagation();
        exitFullscreen();
      };

      // Overlay click to exit
      gallery.querySelector(".overlays").onclick = () => exitFullscreen();

      // Listen for fullscreen changes (including Escape key)
      const changeEventName = fullscreenAPI.getChangeEventName();
      const errorEventName = fullscreenAPI.getErrorEventName();

      if (changeEventName) {
        document.addEventListener(changeEventName, handleFullscreenChange);
      }
      if (errorEventName) {
        document.addEventListener(errorEventName, handleFullscreenError);
      }

      // Store event names for cleanup later
      gallery.dataset.fullscreenChangeEvent = changeEventName;
      gallery.dataset.fullscreenErrorEvent = errorEventName;

      // Keyboard navigation (works in both fullscreen and normal mode)
      const handleGalleryKeys = (e) => {
        // Only handle keys when this gallery is fullscreen
        const fullscreenElement = fullscreenAPI.getElement();
        const isFullscreen =
          fullscreenElement === gallery ||
          gallery.classList.contains("fullscreen-mode");

        if (!isFullscreen) return;

        switch (e.key) {
          case "ArrowLeft":
            e.preventDefault();
            gallery.querySelector(".nav-left").click();
            break;
          case "ArrowRight":
            e.preventDefault();
            gallery.querySelector(".nav-right").click();
            break;
          case "Escape":
            // Only handle Escape in CSS fallback mode
            // Native fullscreen handles Escape automatically
            if (
              gallery.classList.contains("fullscreen-mode") &&
              fullscreenElement !== gallery
            ) {
              e.preventDefault();
              exitFullscreen();
            }
            break;
        }
      };

      // Add keyboard listener to document for fullscreen support
      document.addEventListener("keydown", handleGalleryKeys);

      // Gestures
      let startX = 0;
      gallery.addEventListener(
        "touchstart",
        (e) => (startX = e.changedTouches[0].screenX),
        { passive: true },
      );
      gallery.addEventListener("touchend", (e) => {
        let diff = e.changedTouches[0].screenX - startX;
        if (Math.abs(diff) > 50) {
          index =
            diff > 0
              ? (index - 1 + mediaItems.length) % mediaItems.length
              : (index + 1) % mediaItems.length;
          update();
        }
      });

      // Cleanup for view transitions
      if (!gallery.dataset.cleanupAdded) {
        gallery.dataset.cleanupAdded = "true";

        const cleanup = () => {
          // Exit fullscreen if this gallery is currently fullscreen
          const fullscreenElement = fullscreenAPI.getElement();
          if (fullscreenElement === gallery) {
            fullscreenAPI.exit().catch(() => {});
          }

          // Remove event listeners
          const changeEventName = gallery.dataset.fullscreenChangeEvent;
          const errorEventName = gallery.dataset.fullscreenErrorEvent;

          if (changeEventName) {
            document.removeEventListener(
              changeEventName,
              handleFullscreenChange,
            );
          }
          if (errorEventName) {
            document.removeEventListener(errorEventName, handleFullscreenError);
          }

          document.removeEventListener("keydown", handleGalleryKeys);
        };

        // Clean up on view transition
        document.addEventListener("astro:before-swap", cleanup, { once: true });
      }
    });
  }

  // Initialize
  initGalleries();
  document.addEventListener("astro:after-swap", initGalleries);
</script>
